package Streams.ScenarioBased.ProductOrderExample;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class ProductOrderSolutions {
    public static void main(String[] args) {

        List<Order> orderList=MockDataUtil.getMockOrders();
        List<Product> productsList=MockDataUtil.getMockProducts();


        // 1. Get all orders placed via MOBILE_APP
        /**
         * Hint: Filter orders where the source contains the word "MOBILE_APP".
         * Convert the result to a list and get the size.
         **/

        List<Order> orderListByMobile=orderList
                .stream()
                .filter(order -> order.getSource().equalsIgnoreCase("MOBILE_APP"))
                .collect(Collectors.toList());

//        System.out.println("Orders places by MOBILE_APP : " + orderListByMobile);


        // 2. List all the product names.
        /**
         * Hint:
         * Extract the product names from the product list.
         * Collect them into a new list.
         **/

        List<String> productName=productsList
                .stream()
                .map(product -> product.getProductName())
                .collect(Collectors.toList());

//        System.out.println(" List of product names : " + productName);


        // 3. Count the number of orders placed for each product.
        /**
         * Hint:
         * Group the orders by the product ID.
         * Count how many orders are placed for each product.
         **/

        Map<String,Long> ordersForEachProduct=orderList
                .stream()
                .collect(Collectors.groupingBy(Order::getProductId,Collectors.counting()));

//        System.out.println(" No of orders for each product is : " + ordersForEachProduct);



        // 4. Find the total revenue generated by "Smart Watch" orders.
        /**
         * Hint:
         * First, find the product with the name "Smart Watch".
         * Filter orders based on this product ID and sum (Collectors.summingDouble)  their amounts .
         **/

        String smartWatchProductId=productsList
                .stream()
                .filter(product -> product.getProductName().equalsIgnoreCase("Smart Watch"))
                .findFirst()
                .map(Product::getProductId)
                .get();

        Double totalRevenue=orderList
                .stream()
                .filter(order -> order.getProductId().equalsIgnoreCase(smartWatchProductId))
                .mapToDouble(Order::getOrderAmount).sum();

//        System.out.println(" Total Revenue generated by Smart Watch is : " + totalRevenue);




        // 5. Get a distinct list of payment methods used in the orders.
        /**
         * Hint:
         * Extract the payment methods from the orders .
         * Get only distinct values (no duplicates).
         */
        List<String> distinctPaymentMethods=orderList
                .stream()
                .map(Order::getPaymentMode)
                .distinct()
                .collect(Collectors.toList());

//        System.out.println(" Distinct Payment modes are : " + distinctPaymentMethods);



        // 6. Get the top 2 products with the highest price.
        /**
         * Hint:
         * Sort the products by price in descending order (use .sorted).
         * Limit the result to the top 2 products.
         */

        List<String> productsWithHighestPrice=productsList
                .stream()
                .sorted(Comparator.comparingDouble(Product::getPrice).reversed())
                .limit(2)
                .map(Product::getProductName)
                .collect(Collectors.toList());

//        System.out.println("Two products with highest price : " + productsWithHighestPrice);


        // 7️. Detect duplicate orders (same orderId) and list them.
        /**
         * Hint:
         * Group the orders by order ID (Use Collectors.groupingBy).
         * Iterate through entrySet
         * Filter where value size is greater than 1.
         */

        List<Order> duplicateOrder=orderList
                .stream()
                .collect(Collectors.groupingBy(Order::getOrderId,Collectors.counting()))
                .entrySet()
                .stream()
                .filter(stringLongEntry -> stringLongEntry.getValue()>1)
                .map(Map.Entry::getKey)                // Extract the duplicate order IDs
                .flatMap(dupId -> orderList.stream()
                        .filter(order -> order.getOrderId().equals(dupId)))
                .collect(Collectors.toList());

//        System.out.println("Duplicate orders : " + duplicateOrder);



        // 8.For each product, find total quantity sold across all orders.
        /**
         * Hint:
         * Group the orders by product ID (Use Collectors.groupingBy).
         * Sum the quantities for each product (Use Collectors.summingInt).
         */


        //9️ Find the product whose total revenue is highest.
        /**
         * Hint: Group the orders by product ID and sum the revenue for each(Use
         * Collectors.groupingBy and Collectors.summingDouble).
         * Find the product with the highest total revenue.
         */





        /*  ----------  EXTRA QUESTIONS -----------

            Hints for these q are written in

            BEGINNER TO INTERMEDIATE QUESTIONS

            1. Print all product names using forEach.
            2. Filter and collect all orders where amount > 2000.
            3. Map products to their names and collect to a Set.
            4. Get all distinct product categories.
            5. Flatten a list of orders from multiple users into a single list.
            6. Sort products by name (A-Z), then by price (low to high).
            7. Sort orders by amount in descending order and get top 3.
            8. Find the order with the maximum quantity.
            9. Find the product with the minimum price.
            10. Group orders by payment method.
            11. Find the first product with price above 5000.
            12. Find any order placed via POS.
            13. Check if any product name contains the word "Smart".
            14. Check if all products are in "INR" currency.
            15. Check if no order was placed with amount 0.
            16. Skip the first 3 cheapest products and list the rest.
            17. Limit to 5 orders placed via Web.

            ADVANCED COMBINATIONS

            18. For each category, list the names of products.
            19. Group orders by product ID and for each group get the total amount.
            20. Flatten list of product names per category from a Map<String, List<Product>>.
            21. Find top 3 categories with the most products.
            22. Get a list of all order IDs in uppercase.
            23. Filter orders that are not "CANCELLED", then group by source.
            24. Find if any order has quantity more than 5. If so, print details.
            25. List names of all products sorted by price descending, but skip the most expensive one.

         */
    }
}
